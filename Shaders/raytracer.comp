#version 430

struct Sphere
{
    vec3 center;
    float radius;
    vec3 color;
    float roughness;
};

struct Camera
{
    vec3 position;
    vec3 forward;
    vec3 right;
    vec3 up;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct RenderState
{
    float t;
    vec3 color;
    bool hit;
    vec3 position;
    vec3 normal;
    float roughness;
};

// input/output
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform Camera viewer;
layout(rgba32f, binding = 1) readonly uniform image2D spheres;
layout(rgba32f, binding = 2) readonly uniform image2D noise;
uniform float sphereCount;

RenderState trace(Ray ray);

Sphere unpackSphere(int index);
RenderState hit(Ray ray, Sphere sphere, float tMin, float tMax, RenderState renderState);

void main() {

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(img_output);
    float horizontalCoefficient = ((float(pixel_coords.x) * 2 - screen_size.x) / screen_size.x);
    float verticalCoefficient = ((float(pixel_coords.y) * 2 - screen_size.y) / screen_size.x);

    Ray ray;
    ray.origin = viewer.position;
    ray.direction = viewer.forward + horizontalCoefficient * viewer.right + verticalCoefficient * viewer.up;

    vec3 pixel = vec3(1.0);
    vec3 unit_direction = normalize(ray.direction);
    float t = 0.5 * (unit_direction.z + 1.0);
    pixel = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);

    for (int bounce = 0; bounce < 4; bounce++)
    {
        RenderState renderState = trace(ray);

        if (!renderState.hit) break;

        pixel = pixel * renderState.color;

        ray.origin = renderState.position;
        vec3 variation = imageLoad(noise, ivec2(pixel_coords.x + bounce * screen_size.x, pixel_coords.y)).xyz;
        ray.direction = reflect(ray.direction, renderState.normal);
        ray.direction = normalize(ray.direction + variation * renderState.roughness);
    }

    imageStore(img_output, pixel_coords, vec4(pixel, 1.0));
}

RenderState trace(Ray ray)
{
    float nearestHit = 9999999;
    RenderState renderState;
    renderState.hit = false;

    for (int i = 0; i < sphereCount; i++)
    {
        RenderState newRenderState = hit(ray, unpackSphere(i), 0.001, nearestHit, renderState);

        if (newRenderState.hit)
        {
            nearestHit = newRenderState.t;
            renderState = newRenderState;
        }
    }

    return renderState;
}

RenderState hit(Ray ray, Sphere sphere, float tMin, float tMax, RenderState renderState)
{
    vec3 co = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, co);
    float c = dot(co, co) - sphere.radius * sphere.radius;
    float discriminant = b * b - (4 * a * c);

    if (discriminant > 0)
    {
        float t = (-b - sqrt(discriminant)) / (2 * a);

        if (t > tMin && t < tMax)
        {
            renderState.position = ray.origin + t * ray.direction;
            renderState.normal = normalize(renderState.position - sphere.center);
            renderState.t = t;
            renderState.color = sphere.color;
            renderState.roughness = sphere.roughness;
            renderState.hit = true;
            return renderState;
        }
    }

    renderState.hit = false;
    return renderState;
}

Sphere unpackSphere(int index)
{
    Sphere sphere;
    vec4 attributeChunk = imageLoad(spheres, ivec2(0, index));
    sphere.center = attributeChunk.xyz;
    sphere.radius = attributeChunk.w;

    attributeChunk = imageLoad(spheres, ivec2(1, index));
    sphere.color = attributeChunk.xyz;
    sphere.roughness = attributeChunk.w;

    return sphere;
}